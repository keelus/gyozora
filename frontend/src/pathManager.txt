import { contents, selectedFiles } from "./store"
import { ReadPath, RenderPreview } from '../wailsjs/go/main/App.js';
import { OpenFile } from '../wailsjs/go/main/App.js'

import { CURRENT_PATH, backHistory, forwardHistory, goBackEnabled, goForwardEnabled, previewProgress, currentJob } from "./store";

export async function LoadFolder(newPath, goingBack, goingForward, ignorePathHistory) {
	console.log("Loading folder ðŸ“‚ ...")
	// Check if we are able to open directory
	contents.set([])
	selectedFiles.set([])
	const directoryElements = await ReadPath(newPath)
	// if(error != null) ...
	
	if(!ignorePathHistory) {
		if(goingBack && !goingForward) {
			forwardHistory.update(fHistory => {
				return [...fHistory, CURRENT_PATH]
			})
		} else if (!goingBack && goingForward) {
			backHistory.update(bHistory => {
				return [...bHistory, CURRENT_PATH]
			})
		} else if (!goingBack && !goingForward) {
			backHistory.update(bHistory => {
				return [...bHistory, CURRENT_PATH]
			})
			forwardHistory.set([])
		}
	}

	let unsubscribe = backHistory.subscribe(($backHistory) => {
		goBackEnabled.set($backHistory.length > 0);
	});
	unsubscribe()

	unsubscribe = forwardHistory.subscribe(($forwardHistory) => {
		goForwardEnabled.set($forwardHistory.length > 0);
	});
	unsubscribe()
	
	CURRENT_PATH.set(newPath)

	const newElements = directoryElements.map((element) => ({
		...element,
	}))
	contents.set(newElements)


	let previewTotalCount = directoryElements.filter(element => element.iconClass == "fileImage").length

	// let batchUnix = Math.floor(Date.now() / 1000)
	let batchUnix = Math.floor(Math.random() * 999_999_999)
	currentJob.set(batchUnix)

	previewProgress.set("0")

	let cancelJob = false;
	if (previewTotalCount == 0) {
		console.log("NO PREVIEW NEEDED")
		previewProgress.set("100")
	} else {
		let remaining = previewTotalCount
		unsubscribe = currentJob.subscribe(curJob => {
			console.log("Current job: ", curJob)
		})
		unsubscribe()

		for(let i = 0; i < directoryElements.length; i++ ){
			let unsubscribe = currentJob.subscribe(curJob => {
				if(curJob != batchUnix) {
					console.log("COMPLETLY CANCELLED 0")
					cancelJob = true
				}
			})
			unsubscribe()
			if(cancelJob) break;

			if(directoryElements[i].iconClass != "fileImage") continue;
			// console.log("Calling to render: '" + directoryElements[i].name + "'")
			remaining -= 1 

			let newPreview =  await RenderPreview(directoryElements[i],  batchUnix, remaining);
			previewProgress.set(((previewTotalCount - remaining) * 100 / previewTotalCount).toFixed(2))

			unsubscribe = currentJob.subscribe(curJob => {
				if(curJob != batchUnix) {
					console.log("COMPLETLY CANCELLED 1")
					cancelJob = true
				}
			})
			unsubscribe()
			if(cancelJob) break;

			contents.update(cts => {
				if(cts[i] === undefined) return cts
				cts[i].preview = newPreview.preview
				return cts
			})
		}
	}
	
	unsubscribe = currentJob.subscribe(curJob => {
		if(curJob == batchUnix) {
			console.log("Preview render finished")
			currentJob.set(-1)
		}
	})
	unsubscribe()
}

export function elementClicked(fpath, isfolder) {
	if(isfolder){
		return LoadFolder(fpath, false, false, false)
	}

	OpenFile(fpath)
}

export function buttonGoBack() {
	let allowBack = true
	let unsubscribe = backHistory.subscribe(bHistory => {
		if(bHistory.length == 0) allowBack = false;
	})
	unsubscribe()
	if(!allowBack) return console.log("âœ‹ Can't go back")

	console.log("ðŸ‘ˆ going back")

	let newPath;
	backHistory.update(bHistory => {
		if(history.length > 0) {
			newPath = bHistory.pop();
		}

		return bHistory
	})

	LoadFolder(newPath, true, false, false)
}

export function buttonGoForward() {
	let allowForward = true
	let unsubscribe = backHistory.subscribe(fHistory => {
		if(fHistory.length == 0) allowForward = false;
	})
	unsubscribe()
	if(!allowForward) return console.log("âœ‹ Can't go forward")

	console.log("going forward ðŸ‘‰")

	
	let newPath;
	forwardHistory.update(fHistory => {
		if(history.length > 0) {
			newPath = fHistory.pop();
		}

		return fHistory
	})

	LoadFolder(newPath, false, true, false)
}
